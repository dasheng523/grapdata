<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ReplState" timestamp="1439129714530">{:repl-history {:ide [], :local [&quot;(ns learn.asynclearn)&quot; &quot;(&lt;!! (google \&quot;clojure\&quot;))&quot; &quot;(ns grapproject.core)&quot; &quot;(let [c (chan 10)]\n  (&gt;!! c \&quot;hello\&quot;)\n  (assert (= \&quot;hello\&quot; (&lt;!! c)))\n  (close! c))&quot; &quot;(let [c1 (chan)\n      c2 (chan)]\n  (thread (while true\n            (let [[v ch] (alts!! [c1 c2])]\n              (println \&quot;Read\&quot; v \&quot;from\&quot; ch))))\n  (&gt;!! c1 \&quot;hi\&quot;)\n  (&gt;!! c2 \&quot;there\&quot;))&quot; &quot;(defn addchan []\n  (go (&gt;! ss \&quot;test\&quot;)))\n\n(defn consumechan []\n  (println (go (&lt;! ss))))&quot; &quot;\n(defn addchan []\n  (go (&gt;! ss \&quot;test\&quot;)))\n\n(defn consumechan []\n  (= \&quot;test\&quot; (go (&lt;! ss))))&quot; &quot;(defn consumechan []\n  (= \&quot;test\&quot; (&lt;!! (go (&lt;! ss)))))&quot; &quot;(defn testtest []\n  (consumechan)\n  (addchan))&quot; &quot;(let [c1 (chan)\n      c2 (chan)]\n  (go (while true\n        (let [[v ch] (alts! [c1 c2])]\n          (println \&quot;Read\&quot; v \&quot;from\&quot; ch))))\n  (go (&gt;! c1 \&quot;hi\&quot;))\n  (go (&gt;! c2 \&quot;there\&quot;)))&quot; &quot;(defn addchan []\n  (go (&gt;! ss \&quot;test\&quot;)))\n\n(defn consumechan []\n  (= \&quot;test\&quot; (go (alt! ss))))&quot; &quot;(go-loop []\n         (&lt;! (timeout 1000))\n         (print (&lt;! trade-ch))\n         (recur))\n\n(go\n  (let [timeout-ch (timeout 1000)\n        trade 100]\n    (-&gt;\n      (alt!\n        [[trade-ch trade]] :sent\n        timeout-ch :timed-out)\n      print))) ;;eval this at will&quot; &quot;\n(def trade-ch (chan))\n\n(go-loop []\n  (&lt;! (timeout 1000))\n  (print (&lt;! trade-ch))\n  (recur))\n\n(go\n  (let [timeout-ch (timeout 1000)\n        trade 100]\n    (-&gt;\n      (alt!\n        [[trade-ch trade]] :sent\n        timeout-ch :timed-out)\n      print))) ;;eval this at will&quot; &quot;(go-loop)&quot; &quot;(def trade-ch (chan))&quot; &quot;(go\n  (let [timeout-ch (timeout 1000)\n        trade 100]\n    (-&gt;\n      (alt!\n        [[trade-ch trade]] :sent\n        timeout-ch :timed-out)\n      print))) ;;eval this at will&quot; &quot;(print (&lt;! trade-ch))&quot; &quot;(print (&lt;! trade-ch 55) )&quot; &quot;(print (&gt;! trade-ch 55) )&quot; &quot;(def result-chan (chan))\n\n(def error-chan (chan))\n\n(def dont-care-chan (chan))&quot; &quot;(go\n  (alt!\n    result-chan ([result] (println! (str \&quot;Success: \&quot; result)))\n    error-chan ([error] (println! (str \&quot;Error: \&quot; error)))\n    dont-care-chan (println \&quot;Don't care about the value!\&quot;)))&quot; &quot;(go\n  (alt!\n    result-chan ([result] (println (str \&quot;Success: \&quot; result)))\n    error-chan ([error] (println (str \&quot;Error: \&quot; error)))\n    dont-care-chan (println \&quot;Don't care about the value!\&quot;)))&quot; &quot;(put! result-chan \&quot;Some result\&quot;)&quot; &quot;(&gt;! result-chan \&quot;Some result\&quot;)&quot; &quot;(go (&gt;! result-chan \&quot;Some result\&quot;))&quot; &quot;(go (&gt;! error-chan \&quot;Some result\&quot;))&quot; &quot;\n(let [ch1 (chan)\n      ch2 (chan)]\n  (go (dotimes [i 2]\n        (prn (str \&quot;CH1\&quot; (&lt;! ch1)))))\n  (go (dotimes [i 2]\n        (prn (str \&quot;CH2\&quot; (&lt;! ch2)))))\n  (go (dotimes [i 4]\n        (alts! [[ch1 i] [ch2 i]]))))&quot; &quot;(count chan)&quot; &quot;(.size chan)&quot; &quot;(chan)&quot; &quot;(defn consumechan []\n  (go (spit  \&quot;test.log\&quot; (&lt;! ss))))&quot; &quot;(spit \&quot;test.log\&quot; 5555)&quot; &quot;(addchan)&quot; &quot;(defn consumechan []\n  (go (spit  \&quot;test.log\&quot; (&lt;! ss))))\n&quot; &quot;(consumechan)&quot; &quot;(fetch-url-by-clojure \&quot;http://www.baidu.com\&quot;)&quot; &quot;(grapdata.common)&quot; &quot;(ns grapdata.common)&quot; &quot;(write-file \&quot;error.log\&quot;)&quot; &quot;(post-url-by-clojure \&quot;http://www.baidu.com/s\&quot; {:wd \&quot;test\&quot;})&quot; &quot;()&quot; &quot;\n(post-url-by-clojure \&quot;http://www.baidu.com/s\&quot; {:wd \&quot;test\&quot;})&quot; &quot;1&quot; &quot;(ns grapdata.testmodel)&quot; &quot;(test-insert-grapdata)&quot; &quot;222&quot; &quot;ffirst&quot; &quot;(ns grapdata.model)&quot; &quot;(testest)&quot; &quot;(test-insert-grapdomain)&quot; &quot;(use '[com.ashafa.clutch :only (create-database put-document) :as clutch])&quot; &quot;(def db (create-database \&quot;repl-crud\&quot;))&quot; &quot;\n(put-document db {:_id \&quot;foo\&quot; :some-data \&quot;bar\&quot;})&quot; &quot;\n(put-document db {:_id \&quot;foo44\&quot; :some-data \&quot;bar\&quot;})&quot; &quot;(ns learn.learndriverweb)&quot; &quot;(run)&quot; &quot;(testcluth)&quot; &quot;(tns grapdata.coutchdetail)&quot; &quot;(ns grapdata.coutchdetail)&quot; &quot;(testte3s)&quot; &quot;(test-get)&quot; &quot;(fn tt3 []\n  (fn [] \&quot;dddd\&quot;))&quot; &quot;(def test-chan (async/chan))\n(def datas [1 2 3 4])\n(go (map #(async/&gt;! test-chan %) datas))&quot; &quot;(def test-chan (async/chan))\n(def datas [1 2 3 4])\n(async/go (map #(async/&gt;! test-chan %) datas))&quot; &quot;(.size (.buffer need-to-fetch))&quot; &quot;(.size (.buf need-to-fetch))&quot; &quot;(count (.buf need-to-fetch))&quot; &quot;(def test-chan (async/chan))\n(def datas [1 2 3 4])\n(async/go (map #(async/put! test-chan %) datas))&quot; &quot;(count (.buf test-chan))&quot; &quot;(.length (.buf test-chan))&quot; &quot;(def test-chan (async/chan))&quot; &quot;(async/&gt;! test-chan 1)&quot; &quot;(go (async/&gt;! test-chan 1))&quot; &quot;(async/go (println (async/&gt;! test-chan)))&quot; &quot;(async/go (async/&gt;! test-chan 1))&quot; &quot;(.size (.buff test-chan))&quot; &quot;(.size (.buf test-chan))&quot; &quot;(.buf test-chan)&quot; &quot;(async/go (async/put! test-chan 555))&quot; &quot;(async/go (println (async/&lt;! test-chan)))&quot; &quot;(def test-chan (async/chan))\n(async/go (async/&gt;! test-chan 1))&quot; &quot;(ns grapdata.core)&quot; &quot;(doseq [tt nil]\n  (println tt))&quot; &quot;(doseq [tt nil]\n  (println 22))&quot; &quot;(get-url-by-clojure \&quot;http://www.15fen.com/category.php?id=11111111111\&quot;)&quot; &quot;(:body (get-url-by-clojure \&quot;http://www.15fen.com/category.php?id=11111111111\&quot;))&quot; &quot;(get-url-by-clojure \&quot;http://www.15fen.com/category.php?id=1\&quot;)&quot; &quot;(testtest)&quot;], :remote []}}</component>
</project>